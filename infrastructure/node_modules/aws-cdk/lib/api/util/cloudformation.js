"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParameterValues = exports.TemplateParameters = exports.stabilizeStack = exports.waitForStackDeploy = exports.waitForStackDelete = exports.changeSetHasNoChanges = exports.cleanupOldChangeset = exports.createDiffChangeSet = exports.waitForChangeSet = exports.CloudFormationStack = void 0;
const cx_api_1 = require("@aws-cdk/cx-api");
const stack_status_1 = require("./cloudformation/stack-status");
const template_body_parameter_1 = require("./template-body-parameter");
const logging_1 = require("../../logging");
const serialize_1 = require("../../serialize");
/**
 * Represents an (existing) Stack in CloudFormation
 *
 * Bundle and cache some information that we need during deployment (so we don't have to make
 * repeated calls to CloudFormation).
 */
class CloudFormationStack {
    static async lookup(cfn, stackName, retrieveProcessedTemplate = false) {
        try {
            const response = await cfn.describeStacks({ StackName: stackName }).promise();
            return new CloudFormationStack(cfn, stackName, response.Stacks && response.Stacks[0], retrieveProcessedTemplate);
        }
        catch (e) {
            if (e.code === 'ValidationError' && e.message === `Stack with id ${stackName} does not exist`) {
                return new CloudFormationStack(cfn, stackName, undefined);
            }
            throw e;
        }
    }
    /**
     * Return a copy of the given stack that does not exist
     *
     * It's a little silly that it needs arguments to do that, but there we go.
     */
    static doesNotExist(cfn, stackName) {
        return new CloudFormationStack(cfn, stackName);
    }
    /**
     * From static information (for testing)
     */
    static fromStaticInformation(cfn, stackName, stack) {
        return new CloudFormationStack(cfn, stackName, stack);
    }
    constructor(cfn, stackName, stack, retrieveProcessedTemplate = false) {
        this.cfn = cfn;
        this.stackName = stackName;
        this.stack = stack;
        this.retrieveProcessedTemplate = retrieveProcessedTemplate;
    }
    /**
     * Retrieve the stack's deployed template
     *
     * Cached, so will only be retrieved once. Will return an empty
     * structure if the stack does not exist.
     */
    async template() {
        if (!this.exists) {
            return {};
        }
        if (this._template === undefined) {
            const response = await this.cfn.getTemplate({
                StackName: this.stackName,
                TemplateStage: this.retrieveProcessedTemplate ? 'Processed' : 'Original',
            }).promise();
            this._template = (response.TemplateBody && (0, serialize_1.deserializeStructure)(response.TemplateBody)) || {};
        }
        return this._template;
    }
    /**
     * Whether the stack exists
     */
    get exists() {
        return this.stack !== undefined;
    }
    /**
     * The stack's ID
     *
     * Throws if the stack doesn't exist.
     */
    get stackId() {
        this.assertExists();
        return this.stack.StackId;
    }
    /**
     * The stack's current outputs
     *
     * Empty object if the stack doesn't exist
     */
    get outputs() {
        if (!this.exists) {
            return {};
        }
        const result = {};
        (this.stack.Outputs || []).forEach(output => {
            result[output.OutputKey] = output.OutputValue;
        });
        return result;
    }
    /**
     * The stack's status
     *
     * Special status NOT_FOUND if the stack does not exist.
     */
    get stackStatus() {
        if (!this.exists) {
            return new stack_status_1.StackStatus('NOT_FOUND', 'Stack not found during lookup');
        }
        return stack_status_1.StackStatus.fromStackDescription(this.stack);
    }
    /**
     * The stack's current tags
     *
     * Empty list of the stack does not exist
     */
    get tags() {
        return this.stack?.Tags || [];
    }
    /**
     * Return the names of all current parameters to the stack
     *
     * Empty list if the stack does not exist.
     */
    get parameterNames() {
        return Object.keys(this.parameters);
    }
    /**
     * Return the names and values of all current parameters to the stack
     *
     * Empty object if the stack does not exist.
     */
    get parameters() {
        if (!this.exists) {
            return {};
        }
        const ret = {};
        for (const param of this.stack.Parameters ?? []) {
            ret[param.ParameterKey] = param.ResolvedValue ?? param.ParameterValue;
        }
        return ret;
    }
    /**
     * Return the termination protection of the stack
     */
    get terminationProtection() {
        return this.stack?.EnableTerminationProtection;
    }
    assertExists() {
        if (!this.exists) {
            throw new Error(`No stack named '${this.stackName}'`);
        }
    }
}
exports.CloudFormationStack = CloudFormationStack;
/**
 * Describe a changeset in CloudFormation, regardless of its current state.
 *
 * @param cfn           a CloudFormation client
 * @param stackName     the name of the Stack the ChangeSet belongs to
 * @param changeSetName the name of the ChangeSet
 * @param fetchAll      if true, fetches all pages of the change set description.
 *
 * @returns       CloudFormation information about the ChangeSet
 */
async function describeChangeSet(cfn, stackName, changeSetName, { fetchAll }) {
    const response = await cfn.describeChangeSet({ StackName: stackName, ChangeSetName: changeSetName }).promise();
    // If fetchAll is true, traverse all pages from the change set description.
    while (fetchAll && response.NextToken != null) {
        const nextPage = await cfn.describeChangeSet({
            StackName: stackName,
            ChangeSetName: response.ChangeSetId ?? changeSetName,
            NextToken: response.NextToken,
        }).promise();
        // Consolidate the changes
        if (nextPage.Changes != null) {
            response.Changes = response.Changes != null
                ? response.Changes.concat(nextPage.Changes)
                : nextPage.Changes;
        }
        // Forward the new NextToken
        response.NextToken = nextPage.NextToken;
    }
    return response;
}
/**
 * Waits for a function to return non-+undefined+ before returning.
 *
 * @param valueProvider a function that will return a value that is not +undefined+ once the wait should be over
 * @param timeout     the time to wait between two calls to +valueProvider+
 *
 * @returns       the value that was returned by +valueProvider+
 */
async function waitFor(valueProvider, timeout = 5000) {
    while (true) {
        const result = await valueProvider();
        if (result === null) {
            return undefined;
        }
        else if (result !== undefined) {
            return result;
        }
        await new Promise(cb => setTimeout(cb, timeout));
    }
}
/**
 * Waits for a ChangeSet to be available for triggering a StackUpdate.
 *
 * Will return a changeset that is either ready to be executed or has no changes.
 * Will throw in other cases.
 *
 * @param cfn           a CloudFormation client
 * @param stackName     the name of the Stack that the ChangeSet belongs to
 * @param changeSetName the name of the ChangeSet
 * @param fetchAll      if true, fetches all pages of the ChangeSet before returning.
 *
 * @returns       the CloudFormation description of the ChangeSet
 */
// eslint-disable-next-line max-len
async function waitForChangeSet(cfn, stackName, changeSetName, { fetchAll }) {
    (0, logging_1.debug)('Waiting for changeset %s on stack %s to finish creating...', changeSetName, stackName);
    const ret = await waitFor(async () => {
        const description = await describeChangeSet(cfn, stackName, changeSetName, { fetchAll });
        // The following doesn't use a switch because tsc will not allow fall-through, UNLESS it is allows
        // EVERYWHERE that uses this library directly or indirectly, which is undesirable.
        if (description.Status === 'CREATE_PENDING' || description.Status === 'CREATE_IN_PROGRESS') {
            (0, logging_1.debug)('Changeset %s on stack %s is still creating', changeSetName, stackName);
            return undefined;
        }
        if (description.Status === 'CREATE_COMPLETE' || changeSetHasNoChanges(description)) {
            return description;
        }
        // eslint-disable-next-line max-len
        throw new Error(`Failed to create ChangeSet ${changeSetName} on ${stackName}: ${description.Status || 'NO_STATUS'}, ${description.StatusReason || 'no reason provided'}`);
    });
    if (!ret) {
        throw new Error('Change set took too long to be created; aborting');
    }
    return ret;
}
exports.waitForChangeSet = waitForChangeSet;
/**
 * Create a changeset for a diff operation
 */
async function createDiffChangeSet(options) {
    // `options.stack` has been modified to include any nested stack templates directly inline with its own template, under a special `NestedTemplate` property.
    // Thus the parent template's Resources section contains the nested template's CDK metadata check, which uses Fn::Equals.
    // This causes CreateChangeSet to fail with `Template Error: Fn::Equals cannot be partially collapsed`.
    for (const resource of Object.values((options.stack.template.Resources ?? {}))) {
        if (resource.Type === 'AWS::CloudFormation::Stack') {
            // eslint-disable-next-line no-console
            (0, logging_1.debug)('This stack contains one or more nested stacks, falling back to template-only diff...');
            return undefined;
        }
    }
    return uploadBodyParameterAndCreateChangeSet(options);
}
exports.createDiffChangeSet = createDiffChangeSet;
async function uploadBodyParameterAndCreateChangeSet(options) {
    try {
        const preparedSdk = (await options.deployments.prepareSdkWithDeployRole(options.stack));
        const bodyParameter = await (0, template_body_parameter_1.makeBodyParameterAndUpload)(options.stack, preparedSdk.resolvedEnvironment, preparedSdk.envResources, options.sdkProvider, preparedSdk.stackSdk);
        const cfn = preparedSdk.stackSdk.cloudFormation();
        const exists = (await CloudFormationStack.lookup(cfn, options.stack.stackName, false)).exists;
        options.stream.write('Hold on while we create a read-only change set to get a diff with accurate replacement information (use --no-change-set to use a less accurate but faster template-only diff)\n');
        return await createChangeSet({
            cfn,
            changeSetName: 'cdk-diff-change-set',
            stack: options.stack,
            exists,
            uuid: options.uuid,
            willExecute: options.willExecute,
            bodyParameter,
            parameters: options.parameters,
        });
    }
    catch (e) {
        (0, logging_1.debug)(e.message);
        options.stream.write('Could not create a change set, will base the diff on template differences (run again with -v to see the reason)\n');
        return undefined;
    }
}
async function createChangeSet(options) {
    await cleanupOldChangeset(options.exists, options.changeSetName, options.stack.stackName, options.cfn);
    (0, logging_1.debug)(`Attempting to create ChangeSet with name ${options.changeSetName} for stack ${options.stack.stackName}`);
    const templateParams = TemplateParameters.fromTemplate(options.stack.template);
    const stackParams = templateParams.supplyAll(options.parameters);
    const changeSet = await options.cfn.createChangeSet({
        StackName: options.stack.stackName,
        ChangeSetName: options.changeSetName,
        ChangeSetType: options.exists ? 'UPDATE' : 'CREATE',
        Description: `CDK Changeset for diff ${options.uuid}`,
        ClientToken: `diff${options.uuid}`,
        TemplateURL: options.bodyParameter.TemplateURL,
        TemplateBody: options.bodyParameter.TemplateBody,
        Parameters: stackParams.apiParameters,
        Capabilities: ['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM', 'CAPABILITY_AUTO_EXPAND'],
    }).promise();
    (0, logging_1.debug)('Initiated creation of changeset: %s; waiting for it to finish creating...', changeSet.Id);
    // Fetching all pages if we'll execute, so we can have the correct change count when monitoring.
    const createdChangeSet = await waitForChangeSet(options.cfn, options.stack.stackName, options.changeSetName, { fetchAll: options.willExecute });
    await cleanupOldChangeset(options.exists, options.changeSetName, options.stack.stackName, options.cfn);
    return createdChangeSet;
}
async function cleanupOldChangeset(exists, changeSetName, stackName, cfn) {
    if (exists) {
        // Delete any existing change sets generated by CDK since change set names must be unique.
        // The delete request is successful as long as the stack exists (even if the change set does not exist).
        (0, logging_1.debug)(`Removing existing change set with name ${changeSetName} if it exists`);
        await cfn.deleteChangeSet({ StackName: stackName, ChangeSetName: changeSetName }).promise();
    }
}
exports.cleanupOldChangeset = cleanupOldChangeset;
/**
 * Return true if the given change set has no changes
 *
 * This must be determined from the status, not the 'Changes' array on the
 * object; the latter can be empty because no resources were changed, but if
 * there are changes to Outputs, the change set can still be executed.
 */
function changeSetHasNoChanges(description) {
    const noChangeErrorPrefixes = [
        // Error message for a regular template
        'The submitted information didn\'t contain changes.',
        // Error message when a Transform is involved (see #10650)
        'No updates are to be performed.',
    ];
    return description.Status === 'FAILED'
        && noChangeErrorPrefixes.some(p => (description.StatusReason ?? '').startsWith(p));
}
exports.changeSetHasNoChanges = changeSetHasNoChanges;
/**
 * Waits for a CloudFormation stack to stabilize in a complete/available state
 * after a delete operation is issued.
 *
 * Fails if the stack is in a FAILED state. Will not fail if the stack was
 * already deleted.
 *
 * @param cfn        a CloudFormation client
 * @param stackName      the name of the stack to wait for after a delete
 *
 * @returns     the CloudFormation description of the stabilized stack after the delete attempt
 */
async function waitForStackDelete(cfn, stackName) {
    const stack = await stabilizeStack(cfn, stackName);
    if (!stack) {
        return undefined;
    }
    const status = stack.stackStatus;
    if (status.isFailure) {
        throw new Error(`The stack named ${stackName} is in a failed state. You may need to delete it from the AWS console : ${status}`);
    }
    else if (status.isDeleted) {
        return undefined;
    }
    return stack;
}
exports.waitForStackDelete = waitForStackDelete;
/**
 * Waits for a CloudFormation stack to stabilize in a complete/available state
 * after an update/create operation is issued.
 *
 * Fails if the stack is in a FAILED state, ROLLBACK state, or DELETED state.
 *
 * @param cfn        a CloudFormation client
 * @param stackName      the name of the stack to wait for after an update
 *
 * @returns     the CloudFormation description of the stabilized stack after the update attempt
 */
async function waitForStackDeploy(cfn, stackName) {
    const stack = await stabilizeStack(cfn, stackName);
    if (!stack) {
        return undefined;
    }
    const status = stack.stackStatus;
    if (status.isCreationFailure) {
        throw new Error(`The stack named ${stackName} failed creation, it may need to be manually deleted from the AWS console: ${status}`);
    }
    else if (!status.isDeploySuccess) {
        throw new Error(`The stack named ${stackName} failed to deploy: ${status}`);
    }
    return stack;
}
exports.waitForStackDeploy = waitForStackDeploy;
/**
 * Wait for a stack to become stable (no longer _IN_PROGRESS), returning it
 */
async function stabilizeStack(cfn, stackName) {
    (0, logging_1.debug)('Waiting for stack %s to finish creating or updating...', stackName);
    return waitFor(async () => {
        const stack = await CloudFormationStack.lookup(cfn, stackName);
        if (!stack.exists) {
            (0, logging_1.debug)('Stack %s does not exist', stackName);
            return null;
        }
        const status = stack.stackStatus;
        if (status.isInProgress) {
            (0, logging_1.debug)('Stack %s has an ongoing operation in progress and is not stable (%s)', stackName, status);
            return undefined;
        }
        else if (status.isReviewInProgress) {
            // This may happen if a stack creation operation is interrupted before the ChangeSet execution starts. Recovering
            // from this would requiring manual intervention (deleting or executing the pending ChangeSet), and failing to do
            // so will result in an endless wait here (the ChangeSet wont delete or execute itself). Instead of blocking
            // "forever" we proceed as if the stack was existing and stable. If there is a concurrent operation that just
            // hasn't finished proceeding just yet, either this operation or the concurrent one may fail due to the other one
            // having made progress. Which is fine. I guess.
            (0, logging_1.debug)('Stack %s is in REVIEW_IN_PROGRESS state. Considering this is a stable status (%s)', stackName, status);
        }
        return stack;
    });
}
exports.stabilizeStack = stabilizeStack;
/**
 * The set of (formal) parameters that have been declared in a template
 */
class TemplateParameters {
    static fromTemplate(template) {
        return new TemplateParameters(template.Parameters || {});
    }
    constructor(params) {
        this.params = params;
    }
    /**
     * Calculate stack parameters to pass from the given desired parameter values
     *
     * Will throw if parameters without a Default value or a Previous value are not
     * supplied.
     */
    supplyAll(updates) {
        return new ParameterValues(this.params, updates);
    }
    /**
     * From the template, the given desired values and the current values, calculate the changes to the stack parameters
     *
     * Will take into account parameters already set on the template (will emit
     * 'UsePreviousValue: true' for those unless the value is changed), and will
     * throw if parameters without a Default value or a Previous value are not
     * supplied.
     */
    updateExisting(updates, previousValues) {
        return new ParameterValues(this.params, updates, previousValues);
    }
}
exports.TemplateParameters = TemplateParameters;
/**
 * The set of parameters we're going to pass to a Stack
 */
class ParameterValues {
    constructor(formalParams, updates, previousValues = {}) {
        this.formalParams = formalParams;
        this.values = {};
        this.apiParameters = [];
        const missingRequired = new Array();
        for (const [key, formalParam] of Object.entries(this.formalParams)) {
            // Check updates first, then use the previous value (if available), then use
            // the default (if available).
            //
            // If we don't find a parameter value using any of these methods, then that's an error.
            const updatedValue = updates[key];
            if (updatedValue !== undefined) {
                this.values[key] = updatedValue;
                this.apiParameters.push({ ParameterKey: key, ParameterValue: updates[key] });
                continue;
            }
            if (key in previousValues) {
                this.values[key] = previousValues[key];
                this.apiParameters.push({ ParameterKey: key, UsePreviousValue: true });
                continue;
            }
            if (formalParam.Default !== undefined) {
                this.values[key] = formalParam.Default;
                continue;
            }
            // Oh no
            missingRequired.push(key);
        }
        if (missingRequired.length > 0) {
            throw new Error(`The following CloudFormation Parameters are missing a value: ${missingRequired.join(', ')}`);
        }
        // Just append all supplied overrides that aren't really expected (this
        // will fail CFN but maybe people made typos that they want to be notified
        // of)
        const unknownParam = ([key, _]) => this.formalParams[key] === undefined;
        const hasValue = ([_, value]) => !!value;
        for (const [key, value] of Object.entries(updates).filter(unknownParam).filter(hasValue)) {
            this.values[key] = value;
            this.apiParameters.push({ ParameterKey: key, ParameterValue: value });
        }
    }
    /**
     * Whether this set of parameter updates will change the actual stack values
     */
    hasChanges(currentValues) {
        // If any of the parameters are SSM parameters, deploying must always happen
        // because we can't predict what the values will be. We will allow some
        // parameters to opt out of this check by having a magic string in their description.
        if (Object.values(this.formalParams).some(p => p.Type.startsWith('AWS::SSM::Parameter::') && !p.Description?.includes(cx_api_1.SSMPARAM_NO_INVALIDATE))) {
            return 'ssm';
        }
        // Otherwise we're dirty if:
        // - any of the existing values are removed, or changed
        if (Object.entries(currentValues).some(([key, value]) => !(key in this.values) || value !== this.values[key])) {
            return true;
        }
        // - any of the values we're setting are new
        if (Object.keys(this.values).some(key => !(key in currentValues))) {
            return true;
        }
        return false;
    }
}
exports.ParameterValues = ParameterValues;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWRmb3JtYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjbG91ZGZvcm1hdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw0Q0FBeUQ7QUFHekQsZ0VBQTREO0FBQzVELHVFQUE4RjtBQUM5RiwyQ0FBc0M7QUFDdEMsK0NBQXVEO0FBb0J2RDs7Ozs7R0FLRztBQUNILE1BQWEsbUJBQW1CO0lBQ3ZCLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUN4QixHQUFtQixFQUFFLFNBQWlCLEVBQUUsNEJBQXFDLEtBQUs7UUFFbEYsSUFBSTtZQUNGLE1BQU0sUUFBUSxHQUFHLE1BQU0sR0FBRyxDQUFDLGNBQWMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzlFLE9BQU8sSUFBSSxtQkFBbUIsQ0FBQyxHQUFHLEVBQUUsU0FBUyxFQUFFLFFBQVEsQ0FBQyxNQUFNLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSx5QkFBeUIsQ0FBQyxDQUFDO1NBQ2xIO1FBQUMsT0FBTyxDQUFNLEVBQUU7WUFDZixJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssaUJBQWlCLElBQUksQ0FBQyxDQUFDLE9BQU8sS0FBSyxpQkFBaUIsU0FBUyxpQkFBaUIsRUFBRTtnQkFDN0YsT0FBTyxJQUFJLG1CQUFtQixDQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7YUFDM0Q7WUFDRCxNQUFNLENBQUMsQ0FBQztTQUNUO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsWUFBWSxDQUFDLEdBQW1CLEVBQUUsU0FBaUI7UUFDL0QsT0FBTyxJQUFJLG1CQUFtQixDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxNQUFNLENBQUMscUJBQXFCLENBQUMsR0FBbUIsRUFBRSxTQUFpQixF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X0lOVkFMSURBVEUgfSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB7IENsb3VkRm9ybWF0aW9uIH0gZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgeyBTdGFja1N0YXR1cyB9IGZyb20gJy4vY2xvdWRmb3JtYXRpb24vc3RhY2stc3RhdHVzJztcbmltcG9ydCB7IG1ha2VCb2R5UGFyYW1ldGVyQW5kVXBsb2FkLCBUZW1wbGF0ZUJvZHlQYXJhbWV0ZXIgfSBmcm9tICcuL3RlbXBsYXRlLWJvZHktcGFyYW1ldGVyJztcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBkZXNlcmlhbGl6ZVN0cnVjdHVyZSB9IGZyb20gJy4uLy4uL3NlcmlhbGl6ZSc7XG5pbXBvcnQgeyBTZGtQcm92aWRlciB9IGZyb20gJy4uL2F3cy1hdXRoJztcbmltcG9ydCB7IERlcGxveW1lbnRzIH0gZnJvbSAnLi4vZGVwbG95bWVudHMnO1xuXG5leHBvcnQgdHlwZSBUZW1wbGF0ZSA9IHtcbiAgUGFyYW1ldGVycz86IFJlY29yZDxzdHJpbmcsIFRlbXBsYXRlUGFyYW1ldGVyPjtcbiAgW2tleTogc3RyaW5nXTogYW55O1xufTtcblxuaW50ZXJmYWNlIFRlbXBsYXRlUGFyYW1ldGVyIHtcbiAgVHlwZTogc3RyaW5nO1xuICBEZWZhdWx0PzogYW55O1xuICBEZXNjcmlwdGlvbj86IHN0cmluZztcbiAgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG5leHBvcnQgdHlwZSBSZXNvdXJjZUlkZW50aWZpZXJQcm9wZXJ0aWVzID0gQ2xvdWRGb3JtYXRpb24uUmVzb3VyY2VJZGVudGlmaWVyUHJvcGVydGllcztcbmV4cG9ydCB0eXBlIFJlc291cmNlSWRlbnRpZmllclN1bW1hcmllcyA9IENsb3VkRm9ybWF0aW9uLlJlc291cmNlSWRlbnRpZmllclN1bW1hcmllcztcbmV4cG9ydCB0eXBlIFJlc291cmNlc1RvSW1wb3J0ID0gQ2xvdWRGb3JtYXRpb24uUmVzb3VyY2VzVG9JbXBvcnQ7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiAoZXhpc3RpbmcpIFN0YWNrIGluIENsb3VkRm9ybWF0aW9uXG4gKlxuICogQnVuZGxlIGFuZCBjYWNoZSBzb21lIGluZm9ybWF0aW9uIHRoYXQgd2UgbmVlZCBkdXJpbmcgZGVwbG95bWVudCAoc28gd2UgZG9uJ3QgaGF2ZSB0byBtYWtlXG4gKiByZXBlYXRlZCBjYWxscyB0byBDbG91ZEZvcm1hdGlvbikuXG4gKi9cbmV4cG9ydCBjbGFzcyBDbG91ZEZvcm1hdGlvblN0YWNrIHtcbiAgcHVibGljIHN0YXRpYyBhc3luYyBsb29rdXAoXG4gICAgY2ZuOiBDbG91ZEZvcm1hdGlvbiwgc3RhY2tOYW1lOiBzdHJpbmcsIHJldHJpZXZlUHJvY2Vzc2VkVGVtcGxhdGU6IGJvb2xlYW4gPSBmYWxzZSxcbiAgKTogUHJvbWlzZTxDbG91ZEZvcm1hdGlvblN0YWNrPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2ZuLmRlc2NyaWJlU3RhY2tzKHsgU3RhY2tOYW1lOiBzdGFja05hbWUgfSkucHJvbWlzZSgpO1xuICAgICAgcmV0dXJuIG5ldyBDbG91ZEZvcm1hdGlvblN0YWNrKGNmbiwgc3RhY2tOYW1lLCByZXNwb25zZS5TdGFja3MgJiYgcmVzcG9uc2UuU3RhY2tzWzBdLCByZXRyaWV2ZVByb2Nlc3NlZFRlbXBsYXRlKTtcbiAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgIGlmIChlLmNvZGUgPT09ICdWYWxpZGF0aW9uRXJyb3InICYmIGUubWVzc2FnZSA9PT0gYFN0YWNrIHdpdGggaWQgJHtzdGFja05hbWV9IGRvZXMgbm90IGV4aXN0YCkge1xuICAgICAgICByZXR1cm4gbmV3IENsb3VkRm9ybWF0aW9uU3RhY2soY2ZuLCBzdGFja05hbWUsIHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBnaXZlbiBzdGFjayB0aGF0IGRvZXMgbm90IGV4aXN0XG4gICAqXG4gICAqIEl0J3MgYSBsaXR0bGUgc2lsbHkgdGhhdCBpdCBuZWVkcyBhcmd1bWVudHMgdG8gZG8gdGhhdCwgYnV0IHRoZXJlIHdlIGdvLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBkb2VzTm90RXhpc3QoY2ZuOiBDbG91ZEZvcm1hdGlvbiwgc3RhY2tOYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IENsb3VkRm9ybWF0aW9uU3RhY2soY2ZuLCBzdGFja05hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZyb20gc3RhdGljIGluZm9ybWF0aW9uIChmb3IgdGVzdGluZylcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVN0YXRpY0luZm9ybWF0aW9uKGNmbjogQ2xvdWRGb3JtYXRpb24sIHN0YWNrTmFtZTogc3RyaW5nLCBzdGFjazogQ2xvdWRGb3JtYXRpb24uU3RhY2spIHtcbiAgICByZXR1cm4gbmV3IENsb3VkRm9ybWF0aW9uU3RhY2soY2ZuLCBzdGFja05hbWUsIHN0YWNrKTtcbiAgfVxuXG4gIHByaXZhdGUgX3RlbXBsYXRlOiBhbnk7XG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2ZuOiBDbG91ZEZvcm1hdGlvbiwgcHVibGljIHJlYWRvbmx5IHN0YWNrTmFtZTogc3RyaW5nLCBwcml2YXRlIHJlYWRvbmx5IHN0YWNrPzogQ2xvdWRGb3JtYXRpb24uU3RhY2ssXG4gICAgcHJpdmF0ZSByZWFkb25seSByZXRyaWV2ZVByb2Nlc3NlZFRlbXBsYXRlOiBib29sZWFuID0gZmFsc2UsXG4gICkge1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBzdGFjaydzIGRlcGxveWVkIHRlbXBsYXRlXG4gICAqXG4gICAqIENhY2hlZCwgc28gd2lsbCBvbmx5IGJlIHJldHJpZXZlZCBvbmNlLiBXaWxsIHJldHVybiBhbiBlbXB0eVxuICAgKiBzdHJ1Y3R1cmUgaWYgdGhlIHN0YWNrIGRvZXMgbm90IGV4aXN0LlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHRlbXBsYXRlKCk6IFByb21pc2U8VGVtcGxhdGU+IHtcbiAgICBpZiAoIXRoaXMuZXhpc3RzKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3RlbXBsYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jZm4uZ2V0VGVtcGxhdGUoe1xuICAgICAgICBTdGFja05hbWU6IHRoaXMuc3RhY2tOYW1lLFxuICAgICAgICBUZW1wbGF0ZVN0YWdlOiB0aGlzLnJldHJpZXZlUHJvY2Vzc2VkVGVtcGxhdGUgPyAnUHJvY2Vzc2VkJyA6ICdPcmlnaW5hbCcsXG4gICAgICB9KS5wcm9taXNlKCk7XG4gICAgICB0aGlzLl90ZW1wbGF0ZSA9IChyZXNwb25zZS5UZW1wbGF0ZUJvZHkgJiYgZGVzZXJpYWxpemVTdHJ1Y3R1cmUocmVzcG9uc2UuVGVtcGxhdGVCb2R5KSkgfHwge307XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzdGFjayBleGlzdHNcbiAgICovXG4gIHB1YmxpYyBnZXQgZXhpc3RzKCkge1xuICAgIHJldHVybiB0aGlzLnN0YWNrICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHN0YWNrJ3MgSURcbiAgICpcbiAgICogVGhyb3dzIGlmIHRoZSBzdGFjayBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgcHVibGljIGdldCBzdGFja0lkKCkge1xuICAgIHRoaXMuYXNzZXJ0RXhpc3RzKCk7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2shLlN0YWNrSWQhO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdGFjaydzIGN1cnJlbnQgb3V0cHV0c1xuICAgKlxuICAgKiBFbXB0eSBvYmplY3QgaWYgdGhlIHN0YWNrIGRvZXNuJ3QgZXhpc3RcbiAgICovXG4gIHB1YmxpYyBnZXQgb3V0cHV0cygpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuZXhpc3RzKSB7IHJldHVybiB7fTsgfVxuICAgIGNvbnN0IHJlc3VsdDogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcbiAgICAodGhpcy5zdGFjayEuT3V0cHV0cyB8fCBbXSkuZm9yRWFjaChvdXRwdXQgPT4ge1xuICAgICAgcmVzdWx0W291dHB1dC5PdXRwdXRLZXkhXSA9IG91dHB1dC5PdXRwdXRWYWx1ZSE7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3RhY2sncyBzdGF0dXNcbiAgICpcbiAgICogU3BlY2lhbCBzdGF0dXMgTk9UX0ZPVU5EIGlmIHRoZSBzdGFjayBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIHB1YmxpYyBnZXQgc3RhY2tTdGF0dXMoKTogU3RhY2tTdGF0dXMge1xuICAgIGlmICghdGhpcy5leGlzdHMpIHtcbiAgICAgIHJldHVybiBuZXcgU3RhY2tTdGF0dXMoJ05PVF9GT1VORCcsICdTdGFjayBub3QgZm91bmQgZHVyaW5nIGxvb2t1cCcpO1xuICAgIH1cbiAgICByZXR1cm4gU3RhY2tTdGF0dXMuZnJvbVN0YWNrRGVzY3JpcHRpb24odGhpcy5zdGFjayEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdGFjaydzIGN1cnJlbnQgdGFnc1xuICAgKlxuICAgKiBFbXB0eSBsaXN0IG9mIHRoZSBzdGFjayBkb2VzIG5vdCBleGlzdFxuICAgKi9cbiAgcHVibGljIGdldCB0YWdzKCk6IENsb3VkRm9ybWF0aW9uLlRhZ3Mge1xuICAgIHJldHVybiB0aGlzLnN0YWNrPy5UYWdzIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbmFtZXMgb2YgYWxsIGN1cnJlbnQgcGFyYW1ldGVycyB0byB0aGUgc3RhY2tcbiAgICpcbiAgICogRW1wdHkgbGlzdCBpZiB0aGUgc3RhY2sgZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHBhcmFtZXRlck5hbWVzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5wYXJhbWV0ZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG5hbWVzIGFuZCB2YWx1ZXMgb2YgYWxsIGN1cnJlbnQgcGFyYW1ldGVycyB0byB0aGUgc3RhY2tcbiAgICpcbiAgICogRW1wdHkgb2JqZWN0IGlmIHRoZSBzdGFjayBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIHB1YmxpYyBnZXQgcGFyYW1ldGVycygpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuZXhpc3RzKSB7IHJldHVybiB7fTsgfVxuICAgIGNvbnN0IHJldDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICAgIGZvciAoY29uc3QgcGFyYW0gb2YgdGhpcy5zdGFjayEuUGFyYW1ldGVycyA/PyBbXSkge1xuICAgICAgcmV0W3BhcmFtLlBhcmFtZXRlcktleSFdID0gcGFyYW0uUmVzb2x2ZWRWYWx1ZSA/PyBwYXJhbS5QYXJhbWV0ZXJWYWx1ZSE7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB0ZXJtaW5hdGlvbiBwcm90ZWN0aW9uIG9mIHRoZSBzdGFja1xuICAgKi9cbiAgcHVibGljIGdldCB0ZXJtaW5hdGlvblByb3RlY3Rpb24oKTogYm9vbGVhbiB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2s/LkVuYWJsZVRlcm1pbmF0aW9uUHJvdGVjdGlvbjtcbiAgfVxuXG4gIHByaXZhdGUgYXNzZXJ0RXhpc3RzKCkge1xuICAgIGlmICghdGhpcy5leGlzdHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3RhY2sgbmFtZWQgJyR7dGhpcy5zdGFja05hbWV9J2ApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERlc2NyaWJlIGEgY2hhbmdlc2V0IGluIENsb3VkRm9ybWF0aW9uLCByZWdhcmRsZXNzIG9mIGl0cyBjdXJyZW50IHN0YXRlLlxuICpcbiAqIEBwYXJhbSBjZm4gICAgICAgICAgIGEgQ2xvdWRGb3JtYXRpb24gY2xpZW50XG4gKiBAcGFyYW0gc3RhY2tOYW1lICAgICB0aGUgbmFtZSBvZiB0aGUgU3RhY2sgdGhlIENoYW5nZVNldCBiZWxvbmdzIHRvXG4gKiBAcGFyYW0gY2hhbmdlU2V0TmFtZSB0aGUgbmFtZSBvZiB0aGUgQ2hhbmdlU2V0XG4gKiBAcGFyYW0gZmV0Y2hBbGwgICAgICBpZiB0cnVlLCBmZXRjaGVzIGFsbCBwYWdlcyBvZiB0aGUgY2hhbmdlIHNldCBkZXNjcmlwdGlvbi5cbiAqXG4gKiBAcmV0dXJucyAgICAgICBDbG91ZEZvcm1hdGlvbiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgQ2hhbmdlU2V0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlc2NyaWJlQ2hhbmdlU2V0KFxuICBjZm46IENsb3VkRm9ybWF0aW9uLFxuICBzdGFja05hbWU6IHN0cmluZyxcbiAgY2hhbmdlU2V0TmFtZTogc3RyaW5nLFxuICB7IGZldGNoQWxsIH06IHsgZmV0Y2hBbGw6IGJvb2xlYW4gfSxcbik6IFByb21pc2U8Q2xvdWRGb3JtYXRpb24uRGVzY3JpYmVDaGFuZ2VTZXRPdXRwdXQ+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjZm4uZGVzY3JpYmVDaGFuZ2VTZXQoeyBTdGFja05hbWU6IHN0YWNrTmFtZSwgQ2hhbmdlU2V0TmFtZTogY2hhbmdlU2V0TmFtZSB9KS5wcm9taXNlKCk7XG5cbiAgLy8gSWYgZmV0Y2hBbGwgaXMgdHJ1ZSwgdHJhdmVyc2UgYWxsIHBhZ2VzIGZyb20gdGhlIGNoYW5nZSBzZXQgZGVzY3JpcHRpb24uXG4gIHdoaWxlIChmZXRjaEFsbCAmJiByZXNwb25zZS5OZXh0VG9rZW4gIT0gbnVsbCkge1xuICAgIGNvbnN0IG5leHRQYWdlID0gYXdhaXQgY2ZuLmRlc2NyaWJlQ2hhbmdlU2V0KHtcbiAgICAgIFN0YWNrTmFtZTogc3RhY2tOYW1lLFxuICAgICAgQ2hhbmdlU2V0TmFtZTogcmVzcG9uc2UuQ2hhbmdlU2V0SWQgPz8gY2hhbmdlU2V0TmFtZSxcbiAgICAgIE5leHRUb2tlbjogcmVzcG9uc2UuTmV4dFRva2VuLFxuICAgIH0pLnByb21pc2UoKTtcblxuICAgIC8vIENvbnNvbGlkYXRlIHRoZSBjaGFuZ2VzXG4gICAgaWYgKG5leHRQYWdlLkNoYW5nZXMgIT0gbnVsbCkge1xuICAgICAgcmVzcG9uc2UuQ2hhbmdlcyA9IHJlc3BvbnNlLkNoYW5nZXMgIT0gbnVsbFxuICAgICAgICA/IHJlc3BvbnNlLkNoYW5nZXMuY29uY2F0KG5leHRQYWdlLkNoYW5nZXMpXG4gICAgICAgIDogbmV4dFBhZ2UuQ2hhbmdlcztcbiAgICB9XG5cbiAgICAvLyBGb3J3YXJkIHRoZSBuZXcgTmV4dFRva2VuXG4gICAgcmVzcG9uc2UuTmV4dFRva2VuID0gbmV4dFBhZ2UuTmV4dFRva2VuO1xuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuXG4vKipcbiAqIFdhaXRzIGZvciBhIGZ1bmN0aW9uIHRvIHJldHVybiBub24tK3VuZGVmaW5lZCsgYmVmb3JlIHJldHVybmluZy5cbiAqXG4gKiBAcGFyYW0gdmFsdWVQcm92aWRlciBhIGZ1bmN0aW9uIHRoYXQgd2lsbCByZXR1cm4gYSB2YWx1ZSB0aGF0IGlzIG5vdCArdW5kZWZpbmVkKyBvbmNlIHRoZSB3YWl0IHNob3VsZCBiZSBvdmVyXG4gKiBAcGFyYW0gdGltZW91dCAgICAgdGhlIHRpbWUgdG8gd2FpdCBiZXR3ZWVuIHR3byBjYWxscyB0byArdmFsdWVQcm92aWRlcitcbiAqXG4gKiBAcmV0dXJucyAgICAgICB0aGUgdmFsdWUgdGhhdCB3YXMgcmV0dXJuZWQgYnkgK3ZhbHVlUHJvdmlkZXIrXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHdhaXRGb3I8VD4odmFsdWVQcm92aWRlcjogKCkgPT4gUHJvbWlzZTxUIHwgbnVsbCB8IHVuZGVmaW5lZD4sIHRpbWVvdXQ6IG51bWJlciA9IDUwMDApOiBQcm9taXNlPFQgfCB1bmRlZmluZWQ+IHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWx1ZVByb3ZpZGVyKCk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhd2FpdCBuZXcgUHJvbWlzZShjYiA9PiBzZXRUaW1lb3V0KGNiLCB0aW1lb3V0KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXYWl0cyBmb3IgYSBDaGFuZ2VTZXQgdG8gYmUgYXZhaWxhYmxlIGZvciB0cmlnZ2VyaW5nIGEgU3RhY2tVcGRhdGUuXG4gKlxuICogV2lsbCByZXR1cm4gYSBjaGFuZ2VzZXQgdGhhdCBpcyBlaXRoZXIgcmVhZHkgdG8gYmUgZXhlY3V0ZWQgb3IgaGFzIG5vIGNoYW5nZXMuXG4gKiBXaWxsIHRocm93IGluIG90aGVyIGNhc2VzLlxuICpcbiAqIEBwYXJhbSBjZm4gICAgICAgICAgIGEgQ2xvdWRGb3JtYXRpb24gY2xpZW50XG4gKiBAcGFyYW0gc3RhY2tOYW1lICAgICB0aGUgbmFtZSBvZiB0aGUgU3RhY2sgdGhhdCB0aGUgQ2hhbmdlU2V0IGJlbG9uZ3MgdG9cbiAqIEBwYXJhbSBjaGFuZ2VTZXROYW1lIHRoZSBuYW1lIG9mIHRoZSBDaGFuZ2VTZXRcbiAqIEBwYXJhbSBmZXRjaEFsbCAgICAgIGlmIHRydWUsIGZldGNoZXMgYWxsIHBhZ2VzIG9mIHRoZSBDaGFuZ2VTZXQgYmVmb3JlIHJldHVybmluZy5cbiAqXG4gKiBAcmV0dXJucyAgICAgICB0aGUgQ2xvdWRGb3JtYXRpb24gZGVzY3JpcHRpb24gb2YgdGhlIENoYW5nZVNldFxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JDaGFuZ2VTZXQoXG4gIGNmbjogQ2xvdWRGb3JtYXRpb24sXG4gIHN0YWNrTmFtZTogc3RyaW5nLFxuICBjaGFuZ2VTZXROYW1lOiBzdHJpbmcsXG4gIHsgZmV0Y2hBbGwgfTogeyBmZXRjaEFsbDogYm9vbGVhbiB9LFxuKTogUHJvbWlzZTxDbG91ZEZvcm1hdGlvbi5EZXNjcmliZUNoYW5nZVNldE91dHB1dD4ge1xuICBkZWJ1ZygnV2FpdGluZyBmb3IgY2hhbmdlc2V0ICVzIG9uIHN0YWNrICVzIHRvIGZpbmlzaCBjcmVhdGluZy4uLicsIGNoYW5nZVNldE5hbWUsIHN0YWNrTmFtZSk7XG4gIGNvbnN0IHJldCA9IGF3YWl0IHdhaXRGb3IoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gYXdhaXQgZGVzY3JpYmVDaGFuZ2VTZXQoY2ZuLCBzdGFja05hbWUsIGNoYW5nZVNldE5hbWUsIHsgZmV0Y2hBbGwgfSk7XG4gICAgLy8gVGhlIGZvbGxvd2luZyBkb2Vzbid0IHVzZSBhIHN3aXRjaCBiZWNhdXNlIHRzYyB3aWxsIG5vdCBhbGxvdyBmYWxsLXRocm91Z2gsIFVOTEVTUyBpdCBpcyBhbGxvd3NcbiAgICAvLyBFVkVSWVdIRVJFIHRoYXQgdXNlcyB0aGlzIGxpYnJhcnkgZGlyZWN0bHkgb3IgaW5kaXJlY3RseSwgd2hpY2ggaXMgdW5kZXNpcmFibGUuXG4gICAgaWYgKGRlc2NyaXB0aW9uLlN0YXR1cyA9PT0gJ0NSRUFURV9QRU5ESU5HJyB8fCBkZXNjcmlwdGlvbi5TdGF0dXMgPT09ICdDUkVBVEVfSU5fUFJPR1JFU1MnKSB7XG4gICAgICBkZWJ1ZygnQ2hhbmdlc2V0ICVzIG9uIHN0YWNrICVzIGlzIHN0aWxsIGNyZWF0aW5nJywgY2hhbmdlU2V0TmFtZSwgc3RhY2tOYW1lKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGRlc2NyaXB0aW9uLlN0YXR1cyA9PT0gJ0NSRUFURV9DT01QTEVURScgfHwgY2hhbmdlU2V0SGFzTm9DaGFuZ2VzKGRlc2NyaXB0aW9uKSkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIENoYW5nZVNldCAke2NoYW5nZVNldE5hbWV9IG9uICR7c3RhY2tOYW1lfTogJHtkZXNjcmlwdGlvbi5TdGF0dXMgfHwgJ05PX1NUQVRVUyd9LCAke2Rlc2NyaXB0aW9uLlN0YXR1c1JlYXNvbiB8fCAnbm8gcmVhc29uIHByb3ZpZGVkJ31gKTtcbiAgfSk7XG5cbiAgaWYgKCFyZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoYW5nZSBzZXQgdG9vayB0b28gbG9uZyB0byBiZSBjcmVhdGVkOyBhYm9ydGluZycpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZXhwb3J0IHR5cGUgUHJlcGFyZUNoYW5nZVNldE9wdGlvbnMgPSB7XG4gIHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q7XG4gIGRlcGxveW1lbnRzOiBEZXBsb3ltZW50cztcbiAgdXVpZDogc3RyaW5nO1xuICB3aWxsRXhlY3V0ZTogYm9vbGVhbjtcbiAgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyO1xuICBzdHJlYW06IE5vZGVKUy5Xcml0YWJsZVN0cmVhbTtcbiAgcGFyYW1ldGVyczogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH07XG59XG5cbmV4cG9ydCB0eXBlIENyZWF0ZUNoYW5nZVNldE9wdGlvbnMgPSB7XG4gIGNmbjogQ2xvdWRGb3JtYXRpb247XG4gIGNoYW5nZVNldE5hbWU6IHN0cmluZztcbiAgd2lsbEV4ZWN1dGU6IGJvb2xlYW47XG4gIGV4aXN0czogYm9vbGVhbjtcbiAgdXVpZDogc3RyaW5nO1xuICBzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0O1xuICBib2R5UGFyYW1ldGVyOiBUZW1wbGF0ZUJvZHlQYXJhbWV0ZXI7XG4gIHBhcmFtZXRlcnM6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZCB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNoYW5nZXNldCBmb3IgYSBkaWZmIG9wZXJhdGlvblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlRGlmZkNoYW5nZVNldChvcHRpb25zOiBQcmVwYXJlQ2hhbmdlU2V0T3B0aW9ucyk6IFByb21pc2U8Q2xvdWRGb3JtYXRpb24uRGVzY3JpYmVDaGFuZ2VTZXRPdXRwdXQgfCB1bmRlZmluZWQ+IHtcbiAgLy8gYG9wdGlvbnMuc3RhY2tgIGhhcyBiZWVuIG1vZGlmaWVkIHRvIGluY2x1ZGUgYW55IG5lc3RlZCBzdGFjayB0ZW1wbGF0ZXMgZGlyZWN0bHkgaW5saW5lIHdpdGggaXRzIG93biB0ZW1wbGF0ZSwgdW5kZXIgYSBzcGVjaWFsIGBOZXN0ZWRUZW1wbGF0ZWAgcHJvcGVydHkuXG4gIC8vIFRodXMgdGhlIHBhcmVudCB0ZW1wbGF0ZSdzIFJlc291cmNlcyBzZWN0aW9uIGNvbnRhaW5zIHRoZSBuZXN0ZWQgdGVtcGxhdGUncyBDREsgbWV0YWRhdGEgY2hlY2ssIHdoaWNoIHVzZXMgRm46OkVxdWFscy5cbiAgLy8gVGhpcyBjYXVzZXMgQ3JlYXRlQ2hhbmdlU2V0IHRvIGZhaWwgd2l0aCBgVGVtcGxhdGUgRXJyb3I6IEZuOjpFcXVhbHMgY2Fubm90IGJlIHBhcnRpYWxseSBjb2xsYXBzZWRgLlxuICBmb3IgKGNvbnN0IHJlc291cmNlIG9mIE9iamVjdC52YWx1ZXMoKG9wdGlvbnMuc3RhY2sudGVtcGxhdGUuUmVzb3VyY2VzID8/IHt9KSkpIHtcbiAgICBpZiAoKHJlc291cmNlIGFzIGFueSkuVHlwZSA9PT0gJ0FXUzo6Q2xvdWRGb3JtYXRpb246OlN0YWNrJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGRlYnVnKCdUaGlzIHN0YWNrIGNvbnRhaW5zIG9uZSBvciBtb3JlIG5lc3RlZCBzdGFja3MsIGZhbGxpbmcgYmFjayB0byB0ZW1wbGF0ZS1vbmx5IGRpZmYuLi4nKTtcblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdXBsb2FkQm9keVBhcmFtZXRlckFuZENyZWF0ZUNoYW5nZVNldChvcHRpb25zKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gdXBsb2FkQm9keVBhcmFtZXRlckFuZENyZWF0ZUNoYW5nZVNldChvcHRpb25zOiBQcmVwYXJlQ2hhbmdlU2V0T3B0aW9ucyk6IFByb21pc2U8Q2xvdWRGb3JtYXRpb24uRGVzY3JpYmVDaGFuZ2VTZXRPdXRwdXQgfCB1bmRlZmluZWQ+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwcmVwYXJlZFNkayA9IChhd2FpdCBvcHRpb25zLmRlcGxveW1lbnRzLnByZXBhcmVTZGtXaXRoRGVwbG95Um9sZShvcHRpb25zLnN0YWNrKSk7XG4gICAgY29uc3QgYm9keVBhcmFtZXRlciA9IGF3YWl0IG1ha2VCb2R5UGFyYW1ldGVyQW5kVXBsb2FkKFxuICAgICAgb3B0aW9ucy5zdGFjayxcbiAgICAgIHByZXBhcmVkU2RrLnJlc29sdmVkRW52aXJvbm1lbnQsXG4gICAgICBwcmVwYXJlZFNkay5lbnZSZXNvdXJjZXMsXG4gICAgICBvcHRpb25zLnNka1Byb3ZpZGVyLFxuICAgICAgcHJlcGFyZWRTZGsuc3RhY2tTZGssXG4gICAgKTtcbiAgICBjb25zdCBjZm4gPSBwcmVwYXJlZFNkay5zdGFja1Nkay5jbG91ZEZvcm1hdGlvbigpO1xuICAgIGNvbnN0IGV4aXN0cyA9IChhd2FpdCBDbG91ZEZvcm1hdGlvblN0YWNrLmxvb2t1cChjZm4sIG9wdGlvbnMuc3RhY2suc3RhY2tOYW1lLCBmYWxzZSkpLmV4aXN0cztcblxuICAgIG9wdGlvbnMuc3RyZWFtLndyaXRlKCdIb2xkIG9uIHdoaWxlIHdlIGNyZWF0ZSBhIHJlYWQtb25seSBjaGFuZ2Ugc2V0IHRvIGdldCBhIGRpZmYgd2l0aCBhY2N1cmF0ZSByZXBsYWNlbWVudCBpbmZvcm1hdGlvbiAodXNlIC0tbm8tY2hhbmdlLXNldCB0byB1c2UgYSBsZXNzIGFjY3VyYXRlIGJ1dCBmYXN0ZXIgdGVtcGxhdGUtb25seSBkaWZmKVxcbicpO1xuICAgIHJldHVybiBhd2FpdCBjcmVhdGVDaGFuZ2VTZXQoe1xuICAgICAgY2ZuLFxuICAgICAgY2hhbmdlU2V0TmFtZTogJ2Nkay1kaWZmLWNoYW5nZS1zZXQnLFxuICAgICAgc3RhY2s6IG9wdGlvbnMuc3RhY2ssXG4gICAgICBleGlzdHMsXG4gICAgICB1dWlkOiBvcHRpb25zLnV1aWQsXG4gICAgICB3aWxsRXhlY3V0ZTogb3B0aW9ucy53aWxsRXhlY3V0ZSxcbiAgICAgIGJvZHlQYXJhbWV0ZXIsXG4gICAgICBwYXJhbWV0ZXJzOiBvcHRpb25zLnBhcmFtZXRlcnMsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgIGRlYnVnKGUubWVzc2FnZSk7XG4gICAgb3B0aW9ucy5zdHJlYW0ud3JpdGUoJ0NvdWxkIG5vdCBjcmVhdGUgYSBjaGFuZ2Ugc2V0LCB3aWxsIGJhc2UgdGhlIGRpZmYgb24gdGVtcGxhdGUgZGlmZmVyZW5jZXMgKHJ1biBhZ2FpbiB3aXRoIC12IHRvIHNlZSB0aGUgcmVhc29uKVxcbicpO1xuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVDaGFuZ2VTZXQob3B0aW9uczogQ3JlYXRlQ2hhbmdlU2V0T3B0aW9ucyk6IFByb21pc2U8Q2xvdWRGb3JtYXRpb24uRGVzY3JpYmVDaGFuZ2VTZXRPdXRwdXQ+IHtcbiAgYXdhaXQgY2xlYW51cE9sZENoYW5nZXNldChvcHRpb25zLmV4aXN0cywgb3B0aW9ucy5jaGFuZ2VTZXROYW1lLCBvcHRpb25zLnN0YWNrLnN0YWNrTmFtZSwgb3B0aW9ucy5jZm4pO1xuXG4gIGRlYnVnKGBBdHRlbXB0aW5nIHRvIGNyZWF0ZSBDaGFuZ2VTZXQgd2l0aCBuYW1lICR7b3B0aW9ucy5jaGFuZ2VTZXROYW1lfSBmb3Igc3RhY2sgJHtvcHRpb25zLnN0YWNrLnN0YWNrTmFtZX1gKTtcblxuICBjb25zdCB0ZW1wbGF0ZVBhcmFtcyA9IFRlbXBsYXRlUGFyYW1ldGVycy5mcm9tVGVtcGxhdGUob3B0aW9ucy5zdGFjay50ZW1wbGF0ZSk7XG4gIGNvbnN0IHN0YWNrUGFyYW1zID0gdGVtcGxhdGVQYXJhbXMuc3VwcGx5QWxsKG9wdGlvbnMucGFyYW1ldGVycyk7XG5cbiAgY29uc3QgY2hhbmdlU2V0ID0gYXdhaXQgb3B0aW9ucy5jZm4uY3JlYXRlQ2hhbmdlU2V0KHtcbiAgICBTdGFja05hbWU6IG9wdGlvbnMuc3RhY2suc3RhY2tOYW1lLFxuICAgIENoYW5nZVNldE5hbWU6IG9wdGlvbnMuY2hhbmdlU2V0TmFtZSxcbiAgICBDaGFuZ2VTZXRUeXBlOiBvcHRpb25zLmV4aXN0cyA/ICdVUERBVEUnIDogJ0NSRUFURScsXG4gICAgRGVzY3JpcHRpb246IGBDREsgQ2hhbmdlc2V0IGZvciBkaWZmICR7b3B0aW9ucy51dWlkfWAsXG4gICAgQ2xpZW50VG9rZW46IGBkaWZmJHtvcHRpb25zLnV1aWR9YCxcbiAgICBUZW1wbGF0ZVVSTDogb3B0aW9ucy5ib2R5UGFyYW1ldGVyLlRlbXBsYXRlVVJMLFxuICAgIFRlbXBsYXRlQm9keTogb3B0aW9ucy5ib2R5UGFyYW1ldGVyLlRlbXBsYXRlQm9keSxcbiAgICBQYXJhbWV0ZXJzOiBzdGFja1BhcmFtcy5hcGlQYXJhbWV0ZXJzLFxuICAgIENhcGFiaWxpdGllczogWydDQVBBQklMSVRZX0lBTScsICdDQVBBQklMSVRZX05BTUVEX0lBTScsICdDQVBBQklMSVRZX0FVVE9fRVhQQU5EJ10sXG4gIH0pLnByb21pc2UoKTtcblxuICBkZWJ1ZygnSW5pdGlhdGVkIGNyZWF0aW9uIG9mIGNoYW5nZXNldDogJXM7IHdhaXRpbmcgZm9yIGl0IHRvIGZpbmlzaCBjcmVhdGluZy4uLicsIGNoYW5nZVNldC5JZCk7XG4gIC8vIEZldGNoaW5nIGFsbCBwYWdlcyBpZiB3ZSdsbCBleGVjdXRlLCBzbyB3ZSBjYW4gaGF2ZSB0aGUgY29ycmVjdCBjaGFuZ2UgY291bnQgd2hlbiBtb25pdG9yaW5nLlxuICBjb25zdCBjcmVhdGVkQ2hhbmdlU2V0ID0gYXdhaXQgd2FpdEZvckNoYW5nZVNldChvcHRpb25zLmNmbiwgb3B0aW9ucy5zdGFjay5zdGFja05hbWUsIG9wdGlvbnMuY2hhbmdlU2V0TmFtZSwgeyBmZXRjaEFsbDogb3B0aW9ucy53aWxsRXhlY3V0ZSB9KTtcbiAgYXdhaXQgY2xlYW51cE9sZENoYW5nZXNldChvcHRpb25zLmV4aXN0cywgb3B0aW9ucy5jaGFuZ2VTZXROYW1lLCBvcHRpb25zLnN0YWNrLnN0YWNrTmFtZSwgb3B0aW9ucy5jZm4pO1xuXG4gIHJldHVybiBjcmVhdGVkQ2hhbmdlU2V0O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2xlYW51cE9sZENoYW5nZXNldChleGlzdHM6IGJvb2xlYW4sIGNoYW5nZVNldE5hbWU6IHN0cmluZywgc3RhY2tOYW1lOiBzdHJpbmcsIGNmbjogQ2xvdWRGb3JtYXRpb24pIHtcbiAgaWYgKGV4aXN0cykge1xuICAgIC8vIERlbGV0ZSBhbnkgZXhpc3RpbmcgY2hhbmdlIHNldHMgZ2VuZXJhdGVkIGJ5IENESyBzaW5jZSBjaGFuZ2Ugc2V0IG5hbWVzIG11c3QgYmUgdW5pcXVlLlxuICAgIC8vIFRoZSBkZWxldGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsIGFzIGxvbmcgYXMgdGhlIHN0YWNrIGV4aXN0cyAoZXZlbiBpZiB0aGUgY2hhbmdlIHNldCBkb2VzIG5vdCBleGlzdCkuXG4gICAgZGVidWcoYFJlbW92aW5nIGV4aXN0aW5nIGNoYW5nZSBzZXQgd2l0aCBuYW1lICR7Y2hhbmdlU2V0TmFtZX0gaWYgaXQgZXhpc3RzYCk7XG4gICAgYXdhaXQgY2ZuLmRlbGV0ZUNoYW5nZVNldCh7IFN0YWNrTmFtZTogc3RhY2tOYW1lLCBDaGFuZ2VTZXROYW1lOiBjaGFuZ2VTZXROYW1lIH0pLnByb21pc2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBnaXZlbiBjaGFuZ2Ugc2V0IGhhcyBubyBjaGFuZ2VzXG4gKlxuICogVGhpcyBtdXN0IGJlIGRldGVybWluZWQgZnJvbSB0aGUgc3RhdHVzLCBub3QgdGhlICdDaGFuZ2VzJyBhcnJheSBvbiB0aGVcbiAqIG9iamVjdDsgdGhlIGxhdHRlciBjYW4gYmUgZW1wdHkgYmVjYXVzZSBubyByZXNvdXJjZXMgd2VyZSBjaGFuZ2VkLCBidXQgaWZcbiAqIHRoZXJlIGFyZSBjaGFuZ2VzIHRvIE91dHB1dHMsIHRoZSBjaGFuZ2Ugc2V0IGNhbiBzdGlsbCBiZSBleGVjdXRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoYW5nZVNldEhhc05vQ2hhbmdlcyhkZXNjcmlwdGlvbjogQ2xvdWRGb3JtYXRpb24uRGVzY3JpYmVDaGFuZ2VTZXRPdXRwdXQpIHtcbiAgY29uc3Qgbm9DaGFuZ2VFcnJvclByZWZpeGVzID0gW1xuICAgIC8vIEVycm9yIG1lc3NhZ2UgZm9yIGEgcmVndWxhciB0ZW1wbGF0ZVxuICAgICdUaGUgc3VibWl0dGVkIGluZm9ybWF0aW9uIGRpZG5cXCd0IGNvbnRhaW4gY2hhbmdlcy4nLFxuICAgIC8vIEVycm9yIG1lc3NhZ2Ugd2hlbiBhIFRyYW5zZm9ybSBpcyBpbnZvbHZlZCAoc2VlICMxMDY1MClcbiAgICAnTm8gdXBkYXRlcyBhcmUgdG8gYmUgcGVyZm9ybWVkLicsXG4gIF07XG5cbiAgcmV0dXJuIGRlc2NyaXB0aW9uLlN0YXR1cyA9PT0gJ0ZBSUxFRCdcbiAgICAmJiBub0NoYW5nZUVycm9yUHJlZml4ZXMuc29tZShwID0+IChkZXNjcmlwdGlvbi5TdGF0dXNSZWFzb24gPz8gJycpLnN0YXJ0c1dpdGgocCkpO1xufVxuXG4vKipcbiAqIFdhaXRzIGZvciBhIENsb3VkRm9ybWF0aW9uIHN0YWNrIHRvIHN0YWJpbGl6ZSBpbiBhIGNvbXBsZXRlL2F2YWlsYWJsZSBzdGF0ZVxuICogYWZ0ZXIgYSBkZWxldGUgb3BlcmF0aW9uIGlzIGlzc3VlZC5cbiAqXG4gKiBGYWlscyBpZiB0aGUgc3RhY2sgaXMgaW4gYSBGQUlMRUQgc3RhdGUuIFdpbGwgbm90IGZhaWwgaWYgdGhlIHN0YWNrIHdhc1xuICogYWxyZWFkeSBkZWxldGVkLlxuICpcbiAqIEBwYXJhbSBjZm4gICAgICAgIGEgQ2xvdWRGb3JtYXRpb24gY2xpZW50XG4gKiBAcGFyYW0gc3RhY2tOYW1lICAgICAgdGhlIG5hbWUgb2YgdGhlIHN0YWNrIHRvIHdhaXQgZm9yIGFmdGVyIGEgZGVsZXRlXG4gKlxuICogQHJldHVybnMgICAgIHRoZSBDbG91ZEZvcm1hdGlvbiBkZXNjcmlwdGlvbiBvZiB0aGUgc3RhYmlsaXplZCBzdGFjayBhZnRlciB0aGUgZGVsZXRlIGF0dGVtcHRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JTdGFja0RlbGV0ZShcbiAgY2ZuOiBDbG91ZEZvcm1hdGlvbixcbiAgc3RhY2tOYW1lOiBzdHJpbmcpOiBQcm9taXNlPENsb3VkRm9ybWF0aW9uU3RhY2sgfCB1bmRlZmluZWQ+IHtcblxuICBjb25zdCBzdGFjayA9IGF3YWl0IHN0YWJpbGl6ZVN0YWNrKGNmbiwgc3RhY2tOYW1lKTtcbiAgaWYgKCFzdGFjaykgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgY29uc3Qgc3RhdHVzID0gc3RhY2suc3RhY2tTdGF0dXM7XG4gIGlmIChzdGF0dXMuaXNGYWlsdXJlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc3RhY2sgbmFtZWQgJHtzdGFja05hbWV9IGlzIGluIGEgZmFpbGVkIHN0YXRlLiBZb3UgbWF5IG5lZWQgdG8gZGVsZXRlIGl0IGZyb20gdGhlIEFXUyBjb25zb2xlIDogJHtzdGF0dXN9YCk7XG4gIH0gZWxzZSBpZiAoc3RhdHVzLmlzRGVsZXRlZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHN0YWNrO1xufVxuXG4vKipcbiAqIFdhaXRzIGZvciBhIENsb3VkRm9ybWF0aW9uIHN0YWNrIHRvIHN0YWJpbGl6ZSBpbiBhIGNvbXBsZXRlL2F2YWlsYWJsZSBzdGF0ZVxuICogYWZ0ZXIgYW4gdXBkYXRlL2NyZWF0ZSBvcGVyYXRpb24gaXMgaXNzdWVkLlxuICpcbiAqIEZhaWxzIGlmIHRoZSBzdGFjayBpcyBpbiBhIEZBSUxFRCBzdGF0ZSwgUk9MTEJBQ0sgc3RhdGUsIG9yIERFTEVURUQgc3RhdGUuXG4gKlxuICogQHBhcmFtIGNmbiAgICAgICAgYSBDbG91ZEZvcm1hdGlvbiBjbGllbnRcbiAqIEBwYXJhbSBzdGFja05hbWUgICAgICB0aGUgbmFtZSBvZiB0aGUgc3RhY2sgdG8gd2FpdCBmb3IgYWZ0ZXIgYW4gdXBkYXRlXG4gKlxuICogQHJldHVybnMgICAgIHRoZSBDbG91ZEZvcm1hdGlvbiBkZXNjcmlwdGlvbiBvZiB0aGUgc3RhYmlsaXplZCBzdGFjayBhZnRlciB0aGUgdXBkYXRlIGF0dGVtcHRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JTdGFja0RlcGxveShcbiAgY2ZuOiBDbG91ZEZvcm1hdGlvbixcbiAgc3RhY2tOYW1lOiBzdHJpbmcpOiBQcm9taXNlPENsb3VkRm9ybWF0aW9uU3RhY2sgfCB1bmRlZmluZWQ+IHtcblxuICBjb25zdCBzdGFjayA9IGF3YWl0IHN0YWJpbGl6ZVN0YWNrKGNmbiwgc3RhY2tOYW1lKTtcbiAgaWYgKCFzdGFjaykgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgY29uc3Qgc3RhdHVzID0gc3RhY2suc3RhY2tTdGF0dXM7XG5cbiAgaWYgKHN0YXR1cy5pc0NyZWF0aW9uRmFpbHVyZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHN0YWNrIG5hbWVkICR7c3RhY2tOYW1lfSBmYWlsZWQgY3JlYXRpb24sIGl0IG1heSBuZWVkIHRvIGJlIG1hbnVhbGx5IGRlbGV0ZWQgZnJvbSB0aGUgQVdTIGNvbnNvbGU6ICR7c3RhdHVzfWApO1xuICB9IGVsc2UgaWYgKCFzdGF0dXMuaXNEZXBsb3lTdWNjZXNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc3RhY2sgbmFtZWQgJHtzdGFja05hbWV9IGZhaWxlZCB0byBkZXBsb3k6ICR7c3RhdHVzfWApO1xuICB9XG5cbiAgcmV0dXJuIHN0YWNrO1xufVxuXG4vKipcbiAqIFdhaXQgZm9yIGEgc3RhY2sgdG8gYmVjb21lIHN0YWJsZSAobm8gbG9uZ2VyIF9JTl9QUk9HUkVTUyksIHJldHVybmluZyBpdFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RhYmlsaXplU3RhY2soY2ZuOiBDbG91ZEZvcm1hdGlvbiwgc3RhY2tOYW1lOiBzdHJpbmcpIHtcbiAgZGVidWcoJ1dhaXRpbmcgZm9yIHN0YWNrICVzIHRvIGZpbmlzaCBjcmVhdGluZyBvciB1cGRhdGluZy4uLicsIHN0YWNrTmFtZSk7XG4gIHJldHVybiB3YWl0Rm9yKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBzdGFjayA9IGF3YWl0IENsb3VkRm9ybWF0aW9uU3RhY2subG9va3VwKGNmbiwgc3RhY2tOYW1lKTtcbiAgICBpZiAoIXN0YWNrLmV4aXN0cykge1xuICAgICAgZGVidWcoJ1N0YWNrICVzIGRvZXMgbm90IGV4aXN0Jywgc3RhY2tOYW1lKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzdGF0dXMgPSBzdGFjay5zdGFja1N0YXR1cztcbiAgICBpZiAoc3RhdHVzLmlzSW5Qcm9ncmVzcykge1xuICAgICAgZGVidWcoJ1N0YWNrICVzIGhhcyBhbiBvbmdvaW5nIG9wZXJhdGlvbiBpbiBwcm9ncmVzcyBhbmQgaXMgbm90IHN0YWJsZSAoJXMpJywgc3RhY2tOYW1lLCBzdGF0dXMpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHN0YXR1cy5pc1Jldmlld0luUHJvZ3Jlc3MpIHtcbiAgICAgIC8vIFRoaXMgbWF5IGhhcHBlbiBpZiBhIHN0YWNrIGNyZWF0aW9uIG9wZXJhdGlvbiBpcyBpbnRlcnJ1cHRlZCBiZWZvcmUgdGhlIENoYW5nZVNldCBleGVjdXRpb24gc3RhcnRzLiBSZWNvdmVyaW5nXG4gICAgICAvLyBmcm9tIHRoaXMgd291bGQgcmVxdWlyaW5nIG1hbnVhbCBpbnRlcnZlbnRpb24gKGRlbGV0aW5nIG9yIGV4ZWN1dGluZyB0aGUgcGVuZGluZyBDaGFuZ2VTZXQpLCBhbmQgZmFpbGluZyB0byBkb1xuICAgICAgLy8gc28gd2lsbCByZXN1bHQgaW4gYW4gZW5kbGVzcyB3YWl0IGhlcmUgKHRoZSBDaGFuZ2VTZXQgd29udCBkZWxldGUgb3IgZXhlY3V0ZSBpdHNlbGYpLiBJbnN0ZWFkIG9mIGJsb2NraW5nXG4gICAgICAvLyBcImZvcmV2ZXJcIiB3ZSBwcm9jZWVkIGFzIGlmIHRoZSBzdGFjayB3YXMgZXhpc3RpbmcgYW5kIHN0YWJsZS4gSWYgdGhlcmUgaXMgYSBjb25jdXJyZW50IG9wZXJhdGlvbiB0aGF0IGp1c3RcbiAgICAgIC8vIGhhc24ndCBmaW5pc2hlZCBwcm9jZWVkaW5nIGp1c3QgeWV0LCBlaXRoZXIgdGhpcyBvcGVyYXRpb24gb3IgdGhlIGNvbmN1cnJlbnQgb25lIG1heSBmYWlsIGR1ZSB0byB0aGUgb3RoZXIgb25lXG4gICAgICAvLyBoYXZpbmcgbWFkZSBwcm9ncmVzcy4gV2hpY2ggaXMgZmluZS4gSSBndWVzcy5cbiAgICAgIGRlYnVnKCdTdGFjayAlcyBpcyBpbiBSRVZJRVdfSU5fUFJPR1JFU1Mgc3RhdGUuIENvbnNpZGVyaW5nIHRoaXMgaXMgYSBzdGFibGUgc3RhdHVzICglcyknLCBzdGFja05hbWUsIHN0YXR1cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaGUgc2V0IG9mIChmb3JtYWwpIHBhcmFtZXRlcnMgdGhhdCBoYXZlIGJlZW4gZGVjbGFyZWQgaW4gYSB0ZW1wbGF0ZVxuICovXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVQYXJhbWV0ZXJzIHtcbiAgcHVibGljIHN0YXRpYyBmcm9tVGVtcGxhdGUodGVtcGxhdGU6IFRlbXBsYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBUZW1wbGF0ZVBhcmFtZXRlcnModGVtcGxhdGUuUGFyYW1ldGVycyB8fCB7fSk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHBhcmFtczogUmVjb3JkPHN0cmluZywgVGVtcGxhdGVQYXJhbWV0ZXI+KSB7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHN0YWNrIHBhcmFtZXRlcnMgdG8gcGFzcyBmcm9tIHRoZSBnaXZlbiBkZXNpcmVkIHBhcmFtZXRlciB2YWx1ZXNcbiAgICpcbiAgICogV2lsbCB0aHJvdyBpZiBwYXJhbWV0ZXJzIHdpdGhvdXQgYSBEZWZhdWx0IHZhbHVlIG9yIGEgUHJldmlvdXMgdmFsdWUgYXJlIG5vdFxuICAgKiBzdXBwbGllZC5cbiAgICovXG4gIHB1YmxpYyBzdXBwbHlBbGwodXBkYXRlczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPik6IFBhcmFtZXRlclZhbHVlcyB7XG4gICAgcmV0dXJuIG5ldyBQYXJhbWV0ZXJWYWx1ZXModGhpcy5wYXJhbXMsIHVwZGF0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZyb20gdGhlIHRlbXBsYXRlLCB0aGUgZ2l2ZW4gZGVzaXJlZCB2YWx1ZXMgYW5kIHRoZSBjdXJyZW50IHZhbHVlcywgY2FsY3VsYXRlIHRoZSBjaGFuZ2VzIHRvIHRoZSBzdGFjayBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIFdpbGwgdGFrZSBpbnRvIGFjY291bnQgcGFyYW1ldGVycyBhbHJlYWR5IHNldCBvbiB0aGUgdGVtcGxhdGUgKHdpbGwgZW1pdFxuICAgKiAnVXNlUHJldmlvdXNWYWx1ZTogdHJ1ZScgZm9yIHRob3NlIHVubGVzcyB0aGUgdmFsdWUgaXMgY2hhbmdlZCksIGFuZCB3aWxsXG4gICAqIHRocm93IGlmIHBhcmFtZXRlcnMgd2l0aG91dCBhIERlZmF1bHQgdmFsdWUgb3IgYSBQcmV2aW91cyB2YWx1ZSBhcmUgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKi9cbiAgcHVibGljIHVwZGF0ZUV4aXN0aW5nKHVwZGF0ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD4sIHByZXZpb3VzVmFsdWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogUGFyYW1ldGVyVmFsdWVzIHtcbiAgICByZXR1cm4gbmV3IFBhcmFtZXRlclZhbHVlcyh0aGlzLnBhcmFtcywgdXBkYXRlcywgcHJldmlvdXNWYWx1ZXMpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHNldCBvZiBwYXJhbWV0ZXJzIHdlJ3JlIGdvaW5nIHRvIHBhc3MgdG8gYSBTdGFja1xuICovXG5leHBvcnQgY2xhc3MgUGFyYW1ldGVyVmFsdWVzIHtcbiAgcHVibGljIHJlYWRvbmx5IHZhbHVlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICBwdWJsaWMgcmVhZG9ubHkgYXBpUGFyYW1ldGVyczogQ2xvdWRGb3JtYXRpb24uUGFyYW1ldGVyW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZvcm1hbFBhcmFtczogUmVjb3JkPHN0cmluZywgVGVtcGxhdGVQYXJhbWV0ZXI+LFxuICAgIHVwZGF0ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD4sXG4gICAgcHJldmlvdXNWYWx1ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fSkge1xuXG4gICAgY29uc3QgbWlzc2luZ1JlcXVpcmVkID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuICAgIGZvciAoY29uc3QgW2tleSwgZm9ybWFsUGFyYW1dIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuZm9ybWFsUGFyYW1zKSkge1xuICAgICAgLy8gQ2hlY2sgdXBkYXRlcyBmaXJzdCwgdGhlbiB1c2UgdGhlIHByZXZpb3VzIHZhbHVlIChpZiBhdmFpbGFibGUpLCB0aGVuIHVzZVxuICAgICAgLy8gdGhlIGRlZmF1bHQgKGlmIGF2YWlsYWJsZSkuXG4gICAgICAvL1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgZmluZCBhIHBhcmFtZXRlciB2YWx1ZSB1c2luZyBhbnkgb2YgdGhlc2UgbWV0aG9kcywgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4gICAgICBjb25zdCB1cGRhdGVkVmFsdWUgPSB1cGRhdGVzW2tleV07XG4gICAgICBpZiAodXBkYXRlZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNba2V5XSA9IHVwZGF0ZWRWYWx1ZTtcbiAgICAgICAgdGhpcy5hcGlQYXJhbWV0ZXJzLnB1c2goeyBQYXJhbWV0ZXJLZXk6IGtleSwgUGFyYW1ldGVyVmFsdWU6IHVwZGF0ZXNba2V5XSB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkgaW4gcHJldmlvdXNWYWx1ZXMpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNba2V5XSA9IHByZXZpb3VzVmFsdWVzW2tleV07XG4gICAgICAgIHRoaXMuYXBpUGFyYW1ldGVycy5wdXNoKHsgUGFyYW1ldGVyS2V5OiBrZXksIFVzZVByZXZpb3VzVmFsdWU6IHRydWUgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9ybWFsUGFyYW0uRGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudmFsdWVzW2tleV0gPSBmb3JtYWxQYXJhbS5EZWZhdWx0O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gT2ggbm9cbiAgICAgIG1pc3NpbmdSZXF1aXJlZC5wdXNoKGtleSk7XG4gICAgfVxuXG4gICAgaWYgKG1pc3NpbmdSZXF1aXJlZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmb2xsb3dpbmcgQ2xvdWRGb3JtYXRpb24gUGFyYW1ldGVycyBhcmUgbWlzc2luZyBhIHZhbHVlOiAke21pc3NpbmdSZXF1aXJlZC5qb2luKCcsICcpfWApO1xuICAgIH1cblxuICAgIC8vIEp1c3QgYXBwZW5kIGFsbCBzdXBwbGllZCBvdmVycmlkZXMgdGhhdCBhcmVuJ3QgcmVhbGx5IGV4cGVjdGVkICh0aGlzXG4gICAgLy8gd2lsbCBmYWlsIENGTiBidXQgbWF5YmUgcGVvcGxlIG1hZGUgdHlwb3MgdGhhdCB0aGV5IHdhbnQgdG8gYmUgbm90aWZpZWRcbiAgICAvLyBvZilcbiAgICBjb25zdCB1bmtub3duUGFyYW0gPSAoW2tleSwgX106IFtzdHJpbmcsIGFueV0pID0+IHRoaXMuZm9ybWFsUGFyYW1zW2tleV0gPT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCBoYXNWYWx1ZSA9IChbXywgdmFsdWVdOiBbc3RyaW5nLCBhbnldKSA9PiAhIXZhbHVlO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHVwZGF0ZXMpLmZpbHRlcih1bmtub3duUGFyYW0pLmZpbHRlcihoYXNWYWx1ZSkpIHtcbiAgICAgIHRoaXMudmFsdWVzW2tleV0gPSB2YWx1ZSE7XG4gICAgICB0aGlzLmFwaVBhcmFtZXRlcnMucHVzaCh7IFBhcmFtZXRlcktleToga2V5LCBQYXJhbWV0ZXJWYWx1ZTogdmFsdWUgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBzZXQgb2YgcGFyYW1ldGVyIHVwZGF0ZXMgd2lsbCBjaGFuZ2UgdGhlIGFjdHVhbCBzdGFjayB2YWx1ZXNcbiAgICovXG4gIHB1YmxpYyBoYXNDaGFuZ2VzKGN1cnJlbnRWYWx1ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiBQYXJhbWV0ZXJDaGFuZ2VzIHtcbiAgICAvLyBJZiBhbnkgb2YgdGhlIHBhcmFtZXRlcnMgYXJlIFNTTSBwYXJhbWV0ZXJzLCBkZXBsb3lpbmcgbXVzdCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYmVjYXVzZSB3ZSBjYW4ndCBwcmVkaWN0IHdoYXQgdGhlIHZhbHVlcyB3aWxsIGJlLiBXZSB3aWxsIGFsbG93IHNvbWVcbiAgICAvLyBwYXJhbWV0ZXJzIHRvIG9wdCBvdXQgb2YgdGhpcyBjaGVjayBieSBoYXZpbmcgYSBtYWdpYyBzdHJpbmcgaW4gdGhlaXIgZGVzY3JpcHRpb24uXG4gICAgaWYgKE9iamVjdC52YWx1ZXModGhpcy5mb3JtYWxQYXJhbXMpLnNvbWUocCA9PiBwLlR5cGUuc3RhcnRzV2l0aCgnQVdTOjpTU006OlBhcmFtZXRlcjo6JykgJiYgIXAuRGVzY3JpcHRpb24/LmluY2x1ZGVzKFNTTVBBUkFNX05PX0lOVkFMSURBVEUpKSkge1xuICAgICAgcmV0dXJuICdzc20nO1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSB3ZSdyZSBkaXJ0eSBpZjpcbiAgICAvLyAtIGFueSBvZiB0aGUgZXhpc3RpbmcgdmFsdWVzIGFyZSByZW1vdmVkLCBvciBjaGFuZ2VkXG4gICAgaWYgKE9iamVjdC5lbnRyaWVzKGN1cnJlbnRWYWx1ZXMpLnNvbWUoKFtrZXksIHZhbHVlXSkgPT4gIShrZXkgaW4gdGhpcy52YWx1ZXMpIHx8IHZhbHVlICE9PSB0aGlzLnZhbHVlc1trZXldKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gLSBhbnkgb2YgdGhlIHZhbHVlcyB3ZSdyZSBzZXR0aW5nIGFyZSBuZXdcbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy52YWx1ZXMpLnNvbWUoa2V5ID0+ICEoa2V5IGluIGN1cnJlbnRWYWx1ZXMpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFBhcmFtZXRlckNoYW5nZXMgPSBib29sZWFuIHwgJ3NzbSc7XG4iXX0=